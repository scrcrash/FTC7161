#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     IRSeeker,       sensorI2CMuxController)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     motorTL,       tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorBL,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     motorTR,       tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     motorBR,       tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     motorBrush,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorConveyor, tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    servoHingeL,          tServoNone)
#pragma config(Servo,  srvo_S1_C4_2,    servoGripL,           tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    servoHingeR,          tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servoGripR,           tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void goInches(int inch, int speed)
{
	int tickGoal = 67 * inch;
	int tickTest = nMotorEncoder[motorBR];

	//reset encoders
	nMotorEncoder[motorTR] = 0;
	nMotorEncoder[motorTL] = 0;
	nMotorEncoder[motorBR] = 0;
	nMotorEncoder[motorBL] = 0;

	//move forward until encoder reading is more than the goal
	while(tickTest < tickGoal)
	{
		motor[motorTL] = 60;
		motor[motorTR] = 60;
		motor[motorBL] = 60;
		motor[motorBR] = 60;

		tickTest = nMotorEncoder[motorBR];
	}
}

void goInches(int inch, int speed)
{
	int tickGoal = 67 * inch;

	nMotorEncoder[motorBR] = 0;  //clear the LEGO motor encoders
  nMotorEncoder[motorBL] = 0;
  nMotorEncoder[motorTR] = 0;
  nMotorEncoder[motorTL] = 0;

  nMotorEncoderTarget[motorBR] = tickGoal; //set the target stoping position
  nMotorEncoderTarget[motorBL] = tickGoal;
  nMotorEncoderTarget[motorTR] = tickGoal;
  nMotorEncoderTarget[motorTL] = tickGoal;

  motor[motorBR] = speed; //turn both motors on at 30 percent power
  motor[motorBL] = speed;
  motor[motorTR] = speed;
  motor[motorTL] = speed;

  while (nMotorRunState[motorBR] != runStateIdle || nMotorRunState[motorBL] != runStateIdle ||
  			 nMotorRunState[motorTR] != runStateIdle || nMotorRunState[motorTL] != runStateIdle) //while the encoder wheel turns one revolution
  {
    // This condition waits for motors B + C to come to an idle position. Both motors stop
    // and then jumps out of the loop
  }

  motor[motorBR] = 0; //turn all motors off
  motor[motorBL] = 0;
  motor[motorTR] = 0;
  motor[motorTL] = 0;

  wait1Msec(100);  // wait 3 seconds to see feedback on the debugger screens
                    // open the "NXT Devices" window to see the distance the encoder spins.
                    // the robot will come to a stop at the nMotorEncoderTarget position.
}

task main()
{
goInches(17,60);
}
